\documentclass{article}

\usepackage{amsmath}
\usepackage{epigraph}
\usepackage{csquotes}

\usepackage{hyperref}
\hypersetup{pageanchor=false}



\title{Monoids - best API ever!}
\date{2010-09-30}
\author{Marek Dudek}

\begin{document}

\pagenumbering{gobble}
\maketitle

\newpage
\tableofcontents

\newpage
\pagenumbering{arabic}

\section{Motivation}

    \epigraph{The monoid is a humble algebraic structure, at first glance even downright boring. However, thereâ€™s much more to monoids than meets the eye.}

    \paragraph{}
    Understanding monoids is crucial for building distributed software systems that actually work as intended. 
    Monoids help us in thinking about concurrency and parallelism and thus about distribution.

    \paragraph{}
    Using monoid is getting more for less!

    

\section{Definitions}

\subsection{Semigroup}

    \paragraph{}
    Semigroup is an algebraic structure consisting of a set together with an associative binary operation.

    \begin{align*}
        &(A, \diamond) && \text{set and operator} \\
        a \diamond a &= a && \text{binary operator} \\
        x \diamond (y \diamond z) &= (x \diamond y) \diamond z && \text{associativity law}
    \end{align*}

    \paragraph{}
    Symbol $\diamond$ is often pronounced \textit{append}.

\subsection{Monoid}

    \paragraph{}
    Monoid is a semigroup with identity element.

    \begin{align*}
        \emptyset &\in A \\
        \emptyset \diamond a &= a && \text{left  identity} \\
        a \diamond \emptyset &= a && \text{right identity} 
    \end{align*}

    \paragraph{}
    Symbol $\emptyset$ is often pronounced \textit{empty} or \textit{neutral} element.

\subsection{Concatenation}

    \paragraph{}
    Once we have $\diamond$ operator for two elements we can define concatenation function for multiple elements.

    \begin{align*}
        concat([a_1, a_2, \dots, a_n]) &= a_1 \diamond (a_2 \diamond (\dots (a_{n-1} \diamond a_n))) \\
        concat(l) &= fold_{right}(\diamond, \emptyset, l)
    \end{align*}

    \paragraph{}
    For monoids concatenation of empty list is by definition equal to $\emptyset$.
    Semigroups don't have $\emptyset$ so this function is only defined for a non-empty list.

    \paragraph{}
    Actually most of the time this concatenation of elements of $A$ is what we are really after. We often operate on multiple values of the same type. We just want to boil it down to operating on only two values and extrapolate it to operating on any number of them. This simplifies matter a lot.

    \paragraph{}
    Appilcations of $concat$ can be easily parallelized, recomputed incrementally or cached.


\section{Simple examples}

    \subsection{Semigroup examples}

    \subsubsection{Minimum and maximum of numbers}

    \begin{align*}
        min(min(a, b), c) &= min(a, min(b, c)) \\
        max(max(a, b), c) &= max(a, max(b, c))
    \end{align*}

    We were talking about operators and we are used to $min$ and $max$ being functions. 
    This is only syntax, semantically binary operators and functions of two arguments returning the same type are equivalent:

    \begin{align*}
        min(min(a, b), c) &= (a \min b) \min c \\ 
        max(max(a, b), c) &= (a \max b) \max c 
    \end{align*}

    Minimum and maximum don't have neutral element. 
    We could say that $-\infty$ and $+\infty$ play this role. 
    But they aren't real numbers, they don't belong to a set on which we defined our operator.

    \subsection{Monoid examples}

    \subsubsection{Addition and multiplication of numbers}

    \begin{align*}
        (a + b) + c &= a + (b + c) \\
        (a * b) * c &= a * (b * c)
    \end{align*}
    \begin{align*}
        0 + a = a \\
        1 * a = a  
    \end{align*}

    \subsubsection{Logical disjunction and conjunction}

    \begin{align*}
        (a \vee   b) \vee   c &= a \vee   (b \vee   c) \\
        (a \wedge b) \wedge c &= a \wedge (b \wedge c)
    \end{align*}
    \begin{align*}
        false \vee   a = a \\
        true  \wedge a = a 
    \end{align*}

    \subsubsection{Union and intersection of sets}

    \begin{align*}
        (a \cup b) \cup c &= a \cup (b \cup c) \\
        (a \cap b) \cap c &= a \cap (b \cap c)
    \end{align*}
    \begin{align*}
        \emptyset \cup a = a \\
        \Omega    \cap a = a 
    \end{align*}

    \subsubsection{Appending lists}

    \begin{align*}
        (l_1 \otimes l_2) \otimes l_3 &= l_1 \otimes (l_2 \otimes l_3) \\
        [] \otimes l = l \\
    \end{align*}

    \subsubsection{Appending strings}

    \begin{align*}
        (s_1 \otimes s_2) \otimes s_3 &= s_1 \otimes (s_2 \otimes s_3) \\
        "" \otimes s = s \\
    \end{align*}

    \paragraph{}
    This works because we can treat string as list of characters.

    \section{More fun with semigroups and monoids}
    \subsection{Dual}
    \subsection{Turning semigroup into monoid}

    \paragraph{} 
    Trivial lifted monoid on values that have semigroup as wrapper for option type.

    \subsection{}
    Other wrapper option types.

    \paragraph{}
    First and Last wrappers. Don't require that type of wrapped type have semigroup because they don't perform any operations on them.



    \section{More semigroups (that are not monoids)}

    \paragraph{}
    Adding positive integers is a semigroup, since $0$ is not included in the set.

    \paragraph{}
    Appending of non-empty lists is a semigroup, since empty list is not included in the set.

    \section{More monoids}

    \subsection{Logic}

    Exclusive disjunction and exclusive conjunction are also monoids.

    \newpage

    \section{Function is a monoid!}

    \subsection{Functions to monoid}

    \subsection{Endomorphisms}

    \paragraph{}
    This gets interesting. 
    \paragraph{}
    With semigroups and monoids we had certain deal - only one type available. With value of only one there is not that much that we can do. That is - if we want to think about multiple types later because there is something interesting possible with one. If there isn't (which is possible) than semigroups and monoids do not offer any tools for such type. If we want to talk about only one type we can do certain things.
    \paragraph{}
    We can obviously always call a function, this is what we do in FP. We can also produce it or consume it. So we call a function on one (or multiple) arguments and in exchange get one (or multiple) results. Of the same type:

    \begin{equation}
        f :: (a_1, a_2, ..., a_n) -> (a_1, a_2, ..., a_m)
    \end{equation}

    \section{Applications of semigroups and monoids}

    \subsection{Foldable}

    \subsection{Monoid subclasses}

    \subsection{Monoid actions}

    \subsection{Monoid for applicatives}

    \subsection{Monoid homomorphisms}

    \subsection{Writer monad}

    \subsection{Finger trees}

    \subsection{Options and settings}

    In Cabal, something like Maven for Haskell: 

    \blockquote{Package databases are monoids. Configuration files are monoids. Command line flags and sets of command line flags are monoids. Package build information is a monoid}

    In XMonad, windown manager implemented in Haskell:

    \blockquote{xmonad configuration hooks are monoidal}

    \subsection{Features}

    In GenVoca, a compositional paradigm for defining programs of product lines:

    \blockquote{model is a set of features with a composition operation}

    \newpage

    \section{Useful links}

    \begin{itemize}
        \item \url{https://en.wikibooks.org/wiki/Haskell/Monoids}
        \item \url{http://blog.ploeh.dk/2018/03/12/composite-as-a-monoid/}
        \item \url{https://bartoszmilewski.com/2017/02/09/monoids-on-steroids/}
    \end{itemize}




\end{document}
